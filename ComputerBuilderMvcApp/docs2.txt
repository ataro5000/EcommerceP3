1. Entry Point & Configuration (Program.cs)

Role: This is the starting point of your application. It sets up the web server, configures services the application will use (like controllers, your Cart service, session management), and defines the HTTP request pipeline (how incoming requests are handled).

Interactions:
builder.Services.AddControllersWithViews(): Registers the services needed for MVC controllers and views.
builder.Services.AddSingleton<Cart>(): Registers your Cart class as a singleton service. This means one instance of Cart will be shared across all user requests (suitable for a demo, but for per-user carts, you'd typically use session state and a scoped or transient service).
builder.Services.AddDistributedMemoryCache() and builder.Services.AddSession(): Configure session state, allowing you to store data specific to a user's session.
app.UseStaticFiles(): Allows serving static files from the wwwroot folder (CSS, JavaScript, images).
app.UseRouting(): Enables routing decisions.
app.UseSession(): Enables session state functionality.
app.MapControllerRoute(...): Defines the default URL routing pattern. For example, a URL like /Computers/Details/5 would be routed to the Details action in ComputersController, passing 5 as the id parameter.

Management:
Add Services: If you add new services (e.g., a database context, email service), you'll register them here.
Configure Middleware: The order of app.Use...() calls matters. You can add or reconfigure middleware here.
Change Cart Lifetime: If you decide to change how the cart is managed (e.g., per session instead of singleton), you'd modify its registration here and likely in the CartController to retrieve it from the session.


2. Controllers (Controllers/ folder)

Role: Handle incoming web requests, interact with models (data) and services, and then select a view to send back to the user.

Files: HomeController.cs, ComputersController.cs, ComponentsController.cs, CartController.cs.

Interactions:
Routing: Actions (public methods) in controllers are invoked based on the URL, as defined in Program.cs.
Model Interaction: Controllers fetch data from your Models/ (or in this case, directly from JSON files in Data/) and can pass this data to views. For example, ComputersController loads computer data.
Service Injection: CartController receives an instance of the Cart service through its constructor (dependency injection).
ViewModel Usage: Controllers often populate ViewModels/ with data tailored for a specific view.
Returning Views: Actions typically return View(modelObject) which tells MVC to render a specific .cshtml file, passing the modelObject to it.
Management:
New Features: Add new controllers for new sections of your site (e.g., ReviewsController).
New Actions: Add new public methods to existing controllers to handle new URLs or form submissions (e.g., an action to handle computer customization).
Logic Changes: Modify the C# code within action methods to change how data is processed or what data is sent to a view.


3. Models (Models/ folder)

Role: Represent the data entities of your application and sometimes contain business logic related to that data.
Files: Computer.cs, Component.cs (#attachment:Component.cs), Cart.cs (#attachment:Cart.cs), CartItem.cs (#attachment:CartItem.cs), Review.cs (#attachment:Review.cs), ErrorViewModel.cs (#attachment:ErrorViewModel.cs).
Interactions:
Used by controllers to structure and manipulate data.
Cart.cs has methods like AddItem and RemoveItem that encapsulate cart logic.
Component.cs and Computer.cs define the structure of the items you're loading from your JSON data files.
Management:
Data Structure Changes: If you need to store more information about a computer (e.g., a description), you'd add a property to Computer.cs and update your Data/computers.json accordingly.
New Entities: If you introduce new concepts (e.g., Orders, Customers), you'd create new model classes for them.
4. ViewModels (ViewModels/ folder)

Role: Classes specifically designed to hold and shape data for a particular view. They can combine data from multiple models or present data in a way that's convenient for rendering.
Files: ComputerViewModel.cs (#attachment:ComputerViewModel.cs), CustomizeComputerViewModel.cs (#attachment:CustomizeComputerViewModel.cs).
Interactions:
Controllers create and populate instances of ViewModels.
These instances are passed to the views.
Views use the @model directive to declare the type of ViewModel they expect and access its properties.
Management:
New Views/Complex Data: If a new view needs a specific combination or transformation of data, create a new ViewModel for it.
View Changes: If a view's data requirements change, modify the corresponding ViewModel.


5. Views (Views/ folder)

Role: Contain Razor (.cshtml) files that define the HTML structure and presentation of your application's user interface.
Structure:
Views/ControllerName/ActionName.cshtml: Convention for views tied to specific controller actions (e.g., Index.cshtml (#attachment:Index.cshtml), Details.cshtml (#attachment:Details.cshtml)).
Views/Shared/: Contains views used across multiple parts of the application.
_Layout.cshtml (#attachment:_Layout.cshtml): The main template for your pages (header, navigation, footer). Specific view content is rendered where @RenderBody() is called.
Error.cshtml (#attachment:Error.cshtml): A shared error page.
_ViewImports.cshtml (#attachment:_ViewImports.cshtml): Specifies namespaces and tag helpers available to all views.
_ViewStart.cshtml (#attachment:_ViewStart.cshtml): Code that runs before each view; typically used to set the default layout page.
Interactions:
Receive data from controllers via their @model directive.
Use Razor syntax (C# mixed with HTML) to display dynamic data.
Employ Tag Helpers (e.g., asp-controller, asp-action, asp-route-id) to generate URLs and form elements that integrate with MVC backend.
Forms in views submit data back to controller actions (usually via HTTP POST).
Management:
UI Changes: Modify HTML and Razor syntax in these files to change how pages look and behave.
New Pages: Create new .cshtml files for new actions or features.


6. Data Storage (Data/ folder)

Role: For this project, it holds JSON files that act as a simple database.
Files: computers.json, cpus.json, gpus.json, etc. Moved into a solo: components.json which will mimic a coming database closer. 
Interactions:
Controllers read these files (e.g., in ComputersController.GetComputerById, ComponentsController.LoadComponents) using System.IO.File.ReadAllText and Newtonsoft.Json.JsonConvert.DeserializeObject.
Management:
Content Updates: Directly edit the JSON files to change product information, add new items, or remove old ones.
/* New Data Types: If you add new categories of data (e.g., "Monitors"), you'd create a new JSON file for them and update the relevant controller to load from it.  (No longer needed) */

7. Static Assets (wwwroot/ folder)

Role: The public root for static files that are served directly to the browser without server-side processing.
Files: site.css (#attachment:site.css), site.js (#attachment:site.js), and any client-side libraries (like Bootstrap, jQuery if added manually).
Interactions:
Linked from views, primarily _Layout.cshtml.
Management:
Styling: Modify site.css or add new CSS files to change the appearance.
Client-Side Behavior: Add or modify JavaScript in site.js or other .js files for interactive features in the browser.

How to Manage and Extend:

	Adding a New Feature (e.g., Computer Customization):

		Controller Logic: Add an action in ComputersController (e.g., Customize(int id)) to load a computer and its available components. Add 			another action (e.g., [HttpPost] Customize(CustomizeComputerViewModel model)) to handle the submitted customization.

		ViewModel: Use CustomizeComputerViewModel.cs to pass data to and from the customization view.
		
		View: Create Views/Computers/Customize.cshtml. This view would display the computer, allow users to select different components (dropdowns, 		radio buttons), and submit the form.

		Model/Data: Ensure your Component.cs and component JSON files have all necessary details.

		Cart Integration: The AddToCart action in CartController might need to be adapted or a new action created if customized computers have 			different pricing or component lists.


	Debugging:

		Use breakpoints in your C# controller and model code.
		Use Console.WriteLine() or logging for server-side tracing.
		Use browser developer tools (Console for JavaScript errors, Network tab to inspect requests/responses).
		By understanding these core components and their interactions, you can effectively manage and expand your application. The MVC pattern 			provides a clear separation that helps keep the codebase organized as it grows.